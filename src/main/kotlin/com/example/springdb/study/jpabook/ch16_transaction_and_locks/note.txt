
DB 동시성 문제점 :
    Dirty Read:
        - 트렌젝션1이 커밋하지 않은 데이터(수정 중인 데이터)를 트렌젝션2가 조회가능

    Non-Repeatable Read:
        - 커밋이 완료된 데이터만 읽을 수 있음
        - 한 트렌젝션 내에서 반복해서 조회를 했는데 데이터의 값이 달라 질 수 있음

        트렌젝션1이 조회중, 트렌젝션2가 해당 데이터를 수정
        트렌젝션1은 다시 같은 조회를 하면 결과값이 수정됨(트렌젝션2가 수정했기 때문)
         - 한 트렌젝션 내에서 반복해서 조회를 했는데 결과값이 달라 질 수 있는 현상

    Phantom Read:
        - 반복 조회시 결과의 집합이 달라짐

        하지만 트렌젝션1이 어떠한 조건으로 검색 -> 데이터 5개가 나옴
        트렌젝션2가 어떠한 데이터를 추가/수정/삭제
        트렌젝션1이 다시 같은 조건으로 검색 -> 데이터의 집합(개수)가 달라 질 수 있음


격리 수준:  (격리 수준 낮음 -> 높음 순)

    Read Uncommited : Dirty Read, Non-Repeatable Read, Phantom Read 모두 발생 가능

    Read Commited : Non-Repeatable Read, Phantom Read 발생 가능

    Repeatable Read : Phantom Read 발생 가능

    Serializable: -


낙관적 락과 비관적 락:
    - Jpa의 1차 캐시(영속성 컨텍스트)를 잘 사용하면 DB 격리 수준이 Read Committed 이어도 Repeatable Read 처럼 반복 읽기가 가능하다.
    - Jpa는 DB 격리 수준을 Read Committed로 가정한다.

    낙관적 락:
        - 트렌젝션 대부분이 충돌하지 않을 것이라는 가정
        - Db의 물리적 락을 이용하는것이 아닌 Jpa가 제공하는 버전 관리 기능을 사용
        - 해당 기능을 사용시, 트렌젝션이 커밋되기 전에는 트렌젝션들의 충돌을 알 수 없다.

    비관적 락:
        - 트렌젝션이 충돌이 발생할 것 이라고 가정하고, 일단 락을 걸고 보는 방법
        - DB의 물리적 락을 사용

